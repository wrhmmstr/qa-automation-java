Руководство по практическим заданиям
====================================
При выполнении тренировок настоятельно рекомендуем такую последовательность работы:
1. Внимательно прочитайте раздел Дано
1. Проведите инспекцию заданного кода
1. В случае вопросов обращайтесь к менторам
1. Далее внимательно прочитайте раздел Цели
1. Попробуйте прикинуть в уме, как будет выглядеть итоговое решение
1. Распланируйте последовательность задач: план, что конкретно необходимо реализовать в коде
1. Проведите оценку: сколько это займет?
1. И только в случае существенных трудностей обратитесь к разделу Задачи
1. В разделе Задачи вы найдете готовый конкретный план действий
1. Проведите внутреннюю ретроспективу: что Вы забыли или не учли в собственном плане действий по сравнению с готовым предложенным планом?


Тренировка #01-1: git everyday workflow
==============

Дано
----
- [ ] Данный git-репо на github.com


Цели
----
- [ ] Сделан персональный fork данного репо под своей учетной записью github
- [ ] В этом fork создан pull request: dev -> main c файлом owner.md c ФИО участника
- [ ] Сообщения коммитов следуют соглашению [Conventional Commits](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/)

Задачи
------
- [ ] Существует персональная учетная запись на github
- [ ] Сделан персональный fork данного репо под своей учетной записью github
- [ ] Персональный fork склонирован локально с помощью IDEA
- [ ] Создана ветка dev
- [ ] В ветке dev в корне проекта создан файл owner.md c ФИО участника обучения
- [ ] Произведена фиксация изменений (commit)
- [ ] Произведена публикация изменений (push)
- [ ] Создан pull request изменений из dev в main

Как проверить
-------------
- [ ] На github на странице вашего fork в разделе pull requests наблюдается открытый PR с верным содержимым:
- файл owner.md c ФИО участника
- сообщение коммита следует соглашению



Тренировка #01-2: simple java app compiling
==============

Дано
----
- [ ] Данный git repo с готовой кодовой базой (sourcepath) в папке src/main/java

Цели
----
- [ ] Успешная компиляция простого приложения
- [ ] Успешный запуск простого приложения


Задачи
------
- [ ] В командной оболочке перейдите в папку с заготовкой исходников простого приложения
- [ ] Проведите компиляцию из командной оболочки
- [ ] При необходимости исправьте ошибки компиляции
- [ ] Проведите запуск приложения из командной оболочки


Как проверить
-------------
- [ ] Приложение скомпилировалось без вывода компилятора об ошибках
- [ ] При запуске в командной оболочке наблюдается вывод
```shell
Hello world!
```


Тренировка #01-3: сборка проекта с помощью maven
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта 
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java
- [ ] Конфигурационный файл сборки проекта pom.xml

Цели
----
- [ ] Проведена успешная сборка проекта
- [ ] Проведен успешный запуск полученного приложения

Задачи
------
- [ ] В командной оболочке перейдите в папку проекта
- [ ] Выполните сборку до фаз clean и verify
```shell
mvn clean verify
```
- [ ] Выполните запуск приложения из текущей папки labguide
```shell
 java -classpath target/app-1.0-SNAPSHOT.jar Application
```


Как проверить
-------------
- [ ] Приложение скомпилировалось без вывода компилятора об ошибках
- [ ] При запуске в командной оболочке наблюдается вывод
```shell
Hello world!
```



Тренировка #03-1: Комментарии
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Описан контракт класса ConsolePrinter в javadoc-комментариях

Задачи
------
- [ ] В IDEA откройте ConsolePrinter
- [ ] Добавьте javadoc-комментарий, описывающий 
- назначение класса
- назначение метода
- входные параметры
- побочные эффекты
- автор

Как проверить
-------------
- [ ] В IDEA откройте класс Application
- [ ] Найдите использование класса ConsolePrinter
- [ ] Активируйте функцию Quick Documentation

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #03-2: управление кодовой базой с помощью пакетов
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Задано общее пространство имен для всех классов приложения: `com.tcs.edu`
- [ ] Классы, отвечающие за реализацию вывода, инкапсулированы в подпакет `printer`

Задачи
------
- [ ] Добавить для класса `Application` директиву `package com.tcs.edu`
- [ ] Добавить для класса `ConsolePrinter` директиву `package com.tcs.edu.printer`
- [ ] В классе `Application` использовать второй класс по его полному имени: добавить директиву `import com.tcs.edu.printer.ConsolePrinter`
- [ ] Выполните из консоли запуск приложения
```shell
 java -classpath target/app-1.0-SNAPSHOT.jar com.tcs.edu.Application
```

Как проверить
-------------
- [ ] Приложение успешно компилируется
- [ ] При запуске класса `Application` видим вывод в консоль
```shell
Hello World!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #03-3: Собственные класс и метод
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Создан класс с ответственностью декорирования сообщений с операцией добавления к строке текущего времени
- класс приобщен в соответствующий пакет
- имена пакетов, классов, методов явно выражает намерение разработчика
- текущее время получено с помощью функции системной библиотеки Instant.now()
- склейка строк осуществлена с помощью конкатенации '+'

Задачи
------
- [ ] В sourcepath (src/main/java) cоздайте пакет com.tcs.edu.decorator
- [ ] Создайте класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Создайте статический метод decorate(String message), возвращающий String – обогащенную строку сообщения
- [ ] В методе возвращайте склееную строку, состоящую из результата функции Instant.now() и входного параметра метода – строки сообщения
- [ ] Импортируйте полное имя класса java.time.Instant 
- [ ] В основном классе приложения com.tcs.edu.Application выводите не сообщение, а результат обогащения этого сообщения

Как проверить
-------------
- [ ] Покрытие javadoc-комментариями класса и метода
- [ ] При запуске основного класса приложения вывод похож на следующий:
```shell
2022-03-04T05:29:23.020171Z Hello world!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-1: Переменная метода
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] В методе обогащения строки сообщения введена поясняющая переменная для повышения читабельности кода

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класса com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Результат выражения склейки текущего времени и сообщения сохраняйте в переменную decoratedMessage типа String
- [ ] Возвращайте из метода значение этой переменной

Как проверить
-------------
- [ ] Покрытие javadoc-комментариями класса и метода
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-2: Переменная класса
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавлено глобальное состояние приложения: общая переменная с количеством выведенных сообщений
- [ ] В вывод сообщения добавлено так же, какое по счету это сообщение

Задачи
------
- [ ] В sourcepath (src/main/java) откройте класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Добавьте глобальную (static) переменную messageCount
- [ ] В методе вывода увеличивайте этот счетчик (оператор '++')
- [ ] При формировании итоговой строки обогащенного сообщения вначале добавляйте значение этого счетчика

Как проверить
-------------
- [ ] Для проверки корректности работы программы с состоянием необходимо воспроизвести необходимое состояние
- Единичного вывода теперь недостаточно
- Измените тестовый класс Application, чтобы было более одного вывода сообщения
- [ ] Убедитесь в корректности вывода счетчика
```shell
1 2022-03-04T05:29:23.020171Z Hello world!
2 2022-03-04T05:29:23.020172Z Hello world!
3 2022-03-04T05:29:23.020173Z Hello world!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-3: Вывод типов локальной переменной
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели 
----
- [ ] Упростить код обогащения сообщений с помощью автоматического вывода типа поясняющей переменной

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Измените объявление поясняющей переменной decoratedMessage: вместо явного объявления типа переменной используйте var

Как проверить
-------------
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #04-4: Использование констант
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Защитить код обогащения сообщений от случайных ошибок: зафискировать значение поясняющей переменной

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Измените объявление поясняющей переменной decoratedMessage: добавьте модификатор final

Как проверить
-------------
- [ ] Компилятор не позволит менять значение этой переменной (уже константы)
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #05-1 [optional]: Использование функции `String.format()` 
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Использование форматирования строк по шаблону вместо конкатенации подстрок

Задачи
------
- [ ] Изучить документацию на `String.format()`
- [ ] Заменить конкатенацию подстрок на форматирование по шаблону

Как проверить
-------------
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #05-2: Постраничное форматирование вывода
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Задать в коде константу с количеством выводимых сообщений на "странице" 
- [ ] При выводе разделять "страницы"
```
---
```

Как проверить
-------------
- [ ] Вывод тестового сценария выглядит следующим образом (на примере размера "страницы" == 2)
```shell
1 2022-03-04T05:29:23.020171Z Hello world!
2 2022-03-04T05:29:23.020172Z Hello world!
---
3 2022-03-04T05:29:23.020173Z Hello world!
4 2022-03-04T05:29:23.020173Z Hello world!
---
5 2022-03-04T05:29:23.020173Z Hello world!
6 2022-03-04T05:29:23.020173Z Hello world!
---
```

Задачи
------
- [ ] В классе `com.tinkoff.edu.decorator.TimestampMessageDecorator` задекларировать и проинициализировать глобальную константу `PAGE_SIZE`
- [ ] В методе `decorate()` добавьте проверку на делимость номера текущего сообщения на размер страницы оператором `%`
- [ ] Если делится без остатка, добавьте к выводу строку разделения "страницы"
```
---
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


---


Тренировка #06-1: Уровни значимости сообщений с кодированием перечислением
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Введен перечислимый тип, кодирующий уровень значимости выводимых сообщений:
- MINOR
- REGULAR
- MAJOR
- [ ] В API процедуры вывода первым параметром добавлен уровень значимости выводимого сообщения
- [ ] При выводе к сообщению добавляем вконце уровень важности:
- MINOR: `()`
- REGULAR: `(!)`
- MAJOR: `(!!!)`

Как проверить
-------------
- [ ] Вывод тестового сценария выглядит следующим образом:
```shell
1 2022-03-04T05:29:23.020171Z Hello world! ()
2 2022-03-04T05:29:23.020172Z Hello world! (!)
---
3 2022-03-04T05:29:23.020173Z Hello world! (!)
4 2022-03-04T05:29:23.020173Z Hello world! (!!!)
---
5 2022-03-04T05:29:23.020173Z Hello world! ()
6 2022-03-04T05:29:23.020173Z Hello world! (!!!)
---
```

Задачи
------
- [ ] В пакете `com.tinkoff.edu.decorator` создать enum `Severity` значениями `MINOR, REGULAR, MAJOR` 
- [ ] Принять решение и задокументировать в javadoc, какой класс будет отвечать за строковое представление уровня важности 
- например, "REGULAR" -> "(!)"
- для отображения перечислимого типа в строку использовать конструкцию `switch`
- [ ] Если в дизайне системы появится несколько классов с разными аспектами декорирования, имеет смысл:
- разделять эти классы для поддерживаемости кодовой базы
- для удобства API и его использования имеет смысл ввести новый класс, "склеивающий" итоговую строку сообщения
- такие классы, объединяющие поведение из разных классов в итоговую бизнес-логику, в зависимости от окружающего контекста часто называются:
- Facade, Controller, Service – давайте выберем название `MessageService`
- [ ] Добавить в объединяющую операцию вывода первым параметром уровень значимости

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #06-2: Удобный вывод группы сообщений с varargs и foreach
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API операции вывода возможность задать несколько сообщений 
- уровень значимости остается единым для всех этих сообщений
- API требует минимум одно сообщение для вывода (на этапе компиляции)

Как проверить
-------------
- [ ] Вывод тестового сценария остается неизменным с прошлой тренировки

Задачи
------
- [ ] Поменять сигнатуру метода `MessageService.print`
- `MessageService.print(Severity, String message, String... messages)`
- [ ] Реализовать процессинг vararg c помощью цикла foreach

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #07-1: Вывод отсутствующего сообщения (null)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- Оказывается, входные параметры не примитивных типов могут принимать граничное значение `null` 
- При попытке обратиться к полю или методу по такой ссылке возникает ошибка NPE
- [ ] Необходимо обеспечить корректную работу приложения в случае значения `null` входного параметра (в т.ч. любого из последовательности vararg)
- [ ] На данный момент null-значения просто игнорируем. В дальнейшем API будет возбуждать исключительную ситуацию.

Как проверить
-------------
- [ ] Передать последовательность параметров vararg, где присутствует null
- [ ] null-значения игнорируются, все остальные значения выводятся корректно (в соответствии с прошлыми требованиями) 
- [ ] API не выбрасывает никаких исключений

Задачи
------
- [ ] В логике процессинга входных параметров добавить проверку значения параметра на null
- [ ] Игнорировать обработку таких значений

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #07-2: Вывод последовательности строковых сообщений в режиме прямой и обратной сортировки (ASC/DESC)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API параметр, определяющий порядок вывода сообщений для последовательности строковых параметров vararg
- [ ] Старый API оставить, расширение API реализовать новыми перегружеными методами
- [ ] Код соответствует стилю кодирования и внутренней модели качества

Как проверить
-------------
- [ ] Для режима ASC вывод соответствует прошлым требованиям
- [ ] Для режима DESC сообщения из последовательности vararg выводятся в обратном порядке
```shell
1 2022-03-04T05:29:23.020171Z Hello world 6! ()
2 2022-03-04T05:29:23.020172Z Hello world 5! (!)
---
3 2022-03-04T05:29:23.020173Z Hello world 4! (!)
4 2022-03-04T05:29:23.020173Z Hello world 3! (!!!)
---
5 2022-03-04T05:29:23.020173Z Hello world 2! ()
6 2022-03-04T05:29:23.020173Z Hello world 1! (!!!)
---
```

Задачи
------
- [ ] Реализовать перечислимый тип `MessageOrder` с возможными значениями `ASC` и `DESC`
- [ ] Добавить параметр сортировки в API: `MessageService.print(Severity level, MessageOrder order, String message, String... messages)`
- [ ] Реализовать ветвление по значению параметра сортировки
- [ ] Для значения параметра сортировки `DESC` реализовать обратный цикл итерирования по последовательности vararg:
```
for(счетчик цикла от размера массива vararg - 1 до 0 с уменьшением счетчика на единицу) {
   параметр_типа_vararg[счетчик]
}
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #07-3: Вывод строковых сообщений без дублирования (DISTINCT)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API параметр, определяющий характер дублирования значений сообщений последовательности строковых параметров vararg  
- [ ] Старый API оставить, расширение API реализовать новыми перегружеными методами

Как проверить
-------------
- [ ] Для режима DOUBLES вывод соответствует прошлым требованиям, с дублированием
- [ ] Для режима DISTINCT сообщения из последовательности vararg выводятся без дублирования, даже если в параметре есть повторяющиеся сообщения
- [ ] Код соответствует стилю кодирования и внутренней модели качества

Задачи
------
- [ ] Реализовать перечислимый тип `Doubling` с возможными значениями `DOUBLES` и `DISTINCT`
- [ ] Добавить параметр дублирования в API: `MessageService.print(Severity level, MessageOrder order, Doubling doubling, String message, String... messages)`
- [ ] Реализовать ветвление по значению параметра дублирования
- [ ] Для значения параметра дублирования `DISTINCT` реализовать логику проверки на повтор выводимых сообщений:
- Описать массив выведенных сообщений: кратковременную (локальную) переменную типа массив строк и проинициализировать массивом, по размеру равным длине последовательности vararg
- После вывода сообщения сохранять выведенное сообщение как следующий элемент массива выведенных сообщений
- Перед выводом проверять сообщение на вхождение в массив выведенных сообщений и если сообщение уже выводилось, игнорировать его
- Проверку сообщения на вхождение в массив выведенных сообщений реализовать циклом с проверкой на эквивалентность 

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #08-1: Обсеспечение стабильности API при расширении модели данных путем упаковки сообщения в единую структуру VO/DTO
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Отрефакторить API, упаковав строковое сообщение и уровень значимости единый класс `Message`
- [ ] Обеспечить immutability этого класса

Как проверить
-------------
- [ ] Вывод тестовых сценариев не меняется с прошлой версии кодовой базы
- [ ] API изменяется следующим образом:
```
MessageService.log(Message message, Message... messages)
MessageService.log(MessageOrder order, Message message, Message... messages)
MessageService.log(MessageOrder order, Doubling doubling, Message message, Message... messages)
```

Задачи
------
- [ ] Создать класс `Message` в подпакете `domain`
- [ ] Инкаспсулировать два поля: 
- `String body`
- `Severity severity`
- [ ] Реализовать аксессоры для этих полей
- [ ] Реализовать необходимые конструкторы

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #08-2: Обеспечение гибкости и расширяемости системы с полиморфизмом
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Отрефакторить бизнес-логику:
- [ ] Независимое поведение выделено в отдельные классы
- логика процессинга
- логика декорирования
- логика вывода
- [ ] Операции реализованы как методы _объекта_, а не класса
- [ ] Выделены интерфейсы для описания этого поведения

Как проверить
-------------
- [ ] Вывод тестовых сценариев не меняется с прошлой версии кодовой базы

Задачи
------
- [ ] (Если еще не сделано) Разнести бизнес-логику по классам
- `OrderedDistinctedMessageService`
- `TimestampMessageDecorator`
- `ConsolePrinter`
- [ ] Убрать модификаторы `static` для методов
- [ ] Описать интерфейсы с декларацией соответствующих методов
- `MessageService`
- `MessageDecorator`
- `Printer`
- [ ] Реализовать в классах с бизнес-логикой эти соответствующие интерфейсы

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #08-3 [optional]: Обеспечение большей гибкости и расширяемости системы с примемом DI
==========
  Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Отрефакторить бизнес-логику:
- [ ] Объекты, реализующие конкретный вариант поведения, связываются между собой при их создании 

Как проверить
-------------
- [ ] Вывод тестовых сценариев не меняется с прошлой версии кодовой базы
- [ ] "Сборка" нужного варианта поведения системы осуществляется прямо в тесте:
```
MessageService service = new OrderedDistinctedMessageService(
    new TimestampMessageDecorator(),
    new ConsolePrinter()
);
```

Задачи
------
- [ ] Связать классы бизнес-логики между собой **через поля** типа интерфейса
- [ ] Для связи конкретных реализаций инициализировать эти поля в конструкторе, принимая нужные значения как параметры

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #09-1: Борьба с дублированием с помощью наследования 
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Избавиться от дублирования кода проверки входных параметров путем введения базового общего класса с повторно используемым поведением

Как проверить
-------------
- [ ] Вывод тестовых сценариев не меняется с прошлой версии кодовой базы
- [ ] Отсутсвует дублирование кода проверки входных параметров

Задачи
------
- [ ] Экстактировать код проверки входных параметров в отдельный метод `boolean isArgsValid(...)`
- [ ] Создать базовый абстрактный класс `ValidatedService`
- [ ] Перенести метод проверки входных параметров в базовый класс и унаследовать его
- [ ] Использовать унаследованный метод в сервисах `super.isArgsValid(...);`

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #09-2: Встраивание своего дизайна в общие договоренности системной библиотеки Java
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Объекты класса `Message` можно напрямую выводить в консоль `System.out.println(new Message(...));`
- [ ] Объекты класса `Message` можно сравнивать между собой по значению
- [ ] Объекты класса `Message` можно хранить в коллекциях `HashXXX`

Как проверить
-------------
- [ ] Вывод унаследованных тестовых сценариев не меняется с прошлой версии кодовой базы
- [ ] Добавить в наш "тест" сценарий сравнения одинаковых и неодинаковых сообщений
- [ ] Добавить в наш "тест" сценарий, иллюстрирующий выполнения контракта `equals()/hashCode()`

Задачи
------
- [ ] Реализовать с помощью кодогенератора IDEA метод `Message.toString()`
- [ ] Реализовать с помощью кодогенератора IDEA метод `Message.equals()`
- [ ] Реализовать с помощью кодогенератора IDEA метод `Message.hashCode()`

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


---


Тренировка #10-1: Реализация альтернативных сценариев поведения системы с помощью механизма exceptions
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Повторно используемый код проверки входных параметров выбрасывает `IllegalArgumentException(wrong parameter description)`
- [ ] Код проверки входных параметров в бизнес-логике выбрасывает проверяемое бизнес-исключение `LogException(message)` c первопричиной (cause) `IllegalArgumentException(wrong parameter description)`  

Как проверить
-------------
- [ ] Вывод унаследованных тестовых сценариев не меняется с прошлой версии кодовой базы
- [ ] Добавить в наш "тест" сценарии, иллюстрирующие поведение системы с невалидными входными параметрами сообщения

Задачи
------
- [ ] Метод базового класса `ValidatedService.isArgsValid(...)` при невалидных аргументах выбрасывает `IAE` c пояснением
```
if (someArg == null) throw new IllegalArgumentException("someArg is null"); 
if (otherArg.isEmpty()) throw new IllegalArgumentException("otherArg is empty"); 
```
- [ ] Создать класс исключения бизнес-операции `LogException` с удобными конструкторами
- [ ] Методы сервисов с бизнес-логикой ловят низкоуровневое исключение `IAE`, но все равно обрывают свое выполнение, выбрасывая исключение бизнес-операции
```
try {
    super.isArgsValid(...);
} catch (IAE e) {
    throw new LogException(notValidArgMessage, e);
}
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


---


Тренировка #11-1: Рефакторинг stateless системы в stateful учетную – добавление операции **C**reate
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавляем для `Message` идентификацию для будущего поиска конкретных сообщений: поле `id` типа `UUID` 
- [ ] Вместо печати реализуем сохранение: заменить интерфейс `Printer` на `MessageRepository` с операцией `UUID create(Message message)`
- [ ] Реализуем in-memory хранение сообщений: реализовать класс `HashMapMessageRepository`, реализующий `MessageRepository`
- [ ] Рефакторим реализацию API: бизнес-операция сервиса `log(...)` теперь вместо печати сохраняет сообщение в репозитории

Как проверить
-------------
- [ ] Вывод тестовых сценариев меняется: теперь он пустой
- [ ] Пока API нетестопригодный: корректность сохранения сможем проверить позже, после добавления операции чтения

Задачи
------
- [ ] Добавить поле `Message.id` типа `UUID` и инкапсулировать его с аксессором и мутейтором
- [ ] Задекларировать интефейс `MessageRepository` с операцией `UUID create(Message message)`
- [ ] Реализовать класс `HashMapMessageRepository implements MessageRepository`
- [ ] Для хранения данных выбрать структуру `HashMap`
- [ ] Для корректной работы этой структуры сгенерировать в IDEA у класса `Message` методы `equals()` и `hashCode()`
- [ ] При сохранении сообщения в реализации репозитории генерировать первичный ключ `UUID.randomUUID()` и сохранять его в сообщении и как ключ структуры `Map`  
- [ ] Заменить в бизнес-логике класса сервиса печать на сохранение с использованием интерфейса `MessageRepository`

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #11-2: Добавление операции **R**ead по первичному ключу
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Рефакторим API: добавляем новую бизнес-операцию для сервиса `Message findByPrimaryKey(UUID key)`

Как проверить
-------------
- [ ] Добавить тестовый сценарий сохранения и чтения сообщения

Задачи
------
- [ ] Добавить у сервиса операцию `Message findByPrimaryKey(UUID key)`, которая делегирует на репозиторий
- [ ] Добавить у репозитория операцию `Message findByPrimaryKey(UUID key)`
- [ ] Реализовать операцию с использованием API интерфейса `Map` хранимой в репозитории структуры

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #11-3: Добавление операции **R**ead всех сообщений
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Рефакторим API: добавляем новую бизнес-операцию для сервиса `Collection<Message> findAll()`

Как проверить
-------------
- [ ] Добавить тестовый сценарий сохранения нескольких сообщений и их получения одной операцией

Задачи
------
- [ ] Добавить у сервиса операцию `Collection<Message> findAll()`, которая делегирует на репозиторий
- [ ] Добавить у репозитория операцию `Collection<Message> findAll()`
- [ ] Реализовать операцию с использованием API интерфейса `Map` хранимой в репозитории структуры

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #11-4 [optional]: Добавление операции **R**ead сообщений по уровню значимости
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Рефакторим API: добавляем новую бизнес-операцию для сервиса `Collection<Message> findBySeverity(Severity by)`

Как проверить
-------------
- [ ] Добавить тестовый сценарий сохранения нескольких сообщений c разными уровнями значимости и их получения одной операцией

Задачи
------
- [ ] Добавить у сервиса операцию `Collection<Message> findBySeverity(Severity by)`, которая делегирует на репозиторий
- [ ] Добавить у репозитория операцию `Collection<Message> findBySeverity(Severity by)`
- [ ] Реализовать операцию с использованием цикла итерирования по значениям структуры и императивным отбросом неподходящих значений
**или**
- [ ] Реализовать операцию с использованием Stream API: `messages.values().stream().filter().collect()` с декларативной фильтрацией

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #12-1: Рефакторинг полуавтоматических тестов в полноценные под фреймворк JUnit5
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Тесты теперь:
- автоматические
- изолированные
- встроены в инфраструктуру сборки с Maven

Как проверить
-------------
- [ ] Все автоматические JUnit тесты в тестовом sourcepath выполняются успешно 
- при запуске всех тестов в тестовом sourcepath из IDEA
- при запуске полной сборки с Maven

Задачи
------
- [ ] Разбить существующий неавтоматический "тест" на тестовые сценарии в отдельных методах
- [ ] Отрефакторить их в JUnit-тесты
- [x] Дополнить тестовое покрытие: запроектировать новые необходимые тестовые сценарии и добавить для них автоматические JUnit-тесты  

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #12-2 [optional]: Использование комбинаторов утверждений
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Утверждения в тестах реализованы с помощью Hamcrest или AssertJ на выбор

Как проверить
-------------
- [ ] Количество и результат запуска тестового набора не изменяется с прошлой тренировки

Задачи
------
- [ ] Выбрать библиотеку для композиции утверждений
- [ ] Отрефакторить утверждения в тестах 

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #12-3 [optional]: Использование тестовых наборов (suites)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Тесты сгруппированы в наборы с помощью Nested Tests

Как проверить
-------------
- [ ] Результат отработки полного тестового набора структурирован по вложенным тестам 

Задачи
------
- [ ] Выделить общие фикстуры и подсценарии в тестах 
- [ ] Отрефакторить тесты по стратегии Nested Tests

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #13-1: Сборка docker-образа с приложением
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Установить [Docker](https://www.docker.com/products/docker-desktop/)
- [ ] Собрать запускаемый docker-образ `tinkoff-edu-app:1.0.0` с [приложением](https://www.dropbox.com/s/g0er6zwnsycdrc5/app-dev.jar) при помощи [готового скрипта](app.codegen/Dockerfile) 

Как проверить
-------------
```shell
docker images
```

Задачи
------
- [ ] Скачать [jar с приложением](https://www.dropbox.com/s/g0er6zwnsycdrc5/app-dev.jar) в `app.codegen/build/app.jar`
- [ ] Из папки `app.codegen`
```shell
docker buildx build --tag tinkoff-edu-app:1.0.0 .
```

Отправка на ревью
-----------------
Not reviewable


Тренировка #13-2: Запуск контейнера с приложением
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Запустить приложение в контейнере
- [ ] Проверить работоспособность
- [ ] Остановить 

Как проверить
-------------
- [ ] После запуска перейти в браузере на [главную страницу](http://localhost:8080) приложения
- [ ] Аутентифицироваться как `admin/admin`
- [ ] Проинспектировать [API](http://localhost:8080/admin/docs)

Задачи
------
- [ ] `docker run --name app --detach --publish 8080:8080 tinkoff-edu-app:1.0.0`
- [ ] `docker rm --force app`

Отправка на ревью
-----------------
Not reviewable


Тренировка #13-3: Покрытие REST API c помощью REST Assured
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Покрыть тестами базовые CRUD операции ресурса *Country*

Как проверить
-------------
- [ ] Тестовый набор прогоняется без ошибок

Задачи
------
- [ ] Проинспектировать и вручную попробовать операции в Swagger UI
- [ ] Реализовать минимум 4 основных тестовых сценария для CRUD операций ресурса на REST Assured
- [ ] Обеспечить внутреннее качество тестового кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


---


Тренировка #14-1: Запуск БД в контейнере
==========

Дано
----
- [ ] Скрипт [docker-compose](app.codegen/docker-compose.yml) с необходимыми данными:
- имя образа
- меппинг нужных портов
- переменными окружения, задающих необходимые параметры базы

Цели
----
- [ ] Запустить БД в контейнере

Как проверить
-------------
- [ ] Соединиться из БД-клиента в IDEA к запущенной БД и проинспектировать схему базы данных 

Задачи
------
```shell
docker run --detach --publish <host-port>:<container-port> --env <VAR>=<VALUE> <image>

docker ps --all
docker rm --force <CONTAINER>
```


Тренировка #14-2: Запуск приложения в контейнере с измененной конфигурацией
==========

Дано
----
- [ ] Скрипт [docker-compose](app.codegen/docker-compose.yml) с необходимыми данными:
- имя образа
- меппинг нужных портов
- переменными окружения, задающих необходимые параметры конфигурации приложения

Цели
----
- [ ] Пересобрать образ приложения с последним Dockerfile
- [ ] Запустить приложение в контейнере

Как проверить
-------------
- [ ] [SwaggerUI](http://localhost:8080/admin/docs)
- [ ] [DB type and health](http://localhost:8080/admin/health)

Задачи
------
```shell
docker buildx build --tag tinkoff-edu-app:1.0.0 .
```

```shell
ifconfig # linux
ipconfig # windows
```

```shell
docker run --detach --publish <host-port>:<container-port> --env <VAR>=<VALUE> <image>

docker ps --all
docker rm --force <CONTAINER>
```


Тренировка #14-3 [optional]: Запуск группы контейнеров оркестратором с измененной конфигурацией
==========

Дано
----
- [ ] Скрипт [docker-compose](app.codegen/docker-compose.yml)

Цели
----
Одной командой:
- [ ] Пересобрать образ приложения с последним Dockerfile
- [ ] Запустить БД в контейнере
- [ ] Запустить приложение в контейнере

Как проверить
-------------
- [ ] [SwaggerUI](http://localhost:8080/admin/docs)
- [ ] [DB type and health](http://localhost:8080/admin/health)

Задачи
------
```shell
cd app.codegen

docker-compose up --detach 
```

```shell
docker-compose ps
docker ps -a
```

```shell
docker-compose down
```

Тренировка #14-4: Рефакторинг тестов REST API для обеспечения их автономности и изоляции 
==========

Дано
----
- [ ] Контейнер с БД
- [ ] Контейнер с приложением

Цели
----
- [ ] Обеспечить полную автономность и изоляцию тестов API для CUD-операций ресурса `Country`

Как проверить
-------------
- [ ] любые тесты можно запускать выборочно
- [ ] тесты можно запускать в любом порядке
- [ ] тесты можно запускать многократно
- [ ] тесты можно запускать с "пустой" БД (со схемой, но без фейковых тестовых данных)

Задачи
------
- [ ] Реализовать соединение с БД перед первым тестом
- [ ] Реализовать подготовку тестовых данных вначале каждого теста
- [ ] Реализовать тестовую логику работы с REST API
- [ ] Реализовать очистку измененных данных в конце каждого теста
- [ ] Реализовать отсоединение от БД в после последнего теста


Тренировка #14-5 [optional]: Рефакторинг схемы БД и тестовых фикстур на автогенерируемые ключи
==========

Дано
----
- [ ] Контейнер с БД
- [ ] Контейнер с приложением

Цели
----
- [ ] Изменить схему БД: автогенерировать на стороне БД ключи таблицы `Country`
- [ ] Обновить фикстуры тестов

Как проверить
-------------
- [ ] Обновленный тестовый набор выполняется с сохранением требований к изолированности и автономности тестов

Задачи
------
- [ ] Изменить DDL:
```sql
id bigint generated always as identity primary key
```

- [ ] Извлечение ключа после вставки записи в тестах:
```java
sql = connection.prepareStatement(..., Statement.RETURN_GENERATED_KEYS);
...
sql.getGeneratedKeys();
```

